\section{Programmeringsprog}
Da vi skulle vælge hvilket værktøj vi ville implementere vores projekt i gjorde vi os ikke specielt mange overvejelser. 
Vores valg faldt hurtigt på python numpy og scipy, da vi tidligere havde stiftet bekendskab med Matlab, og begge var af samme opfattelse nemlig
at det syntaksen i Matlabs scripingsprog langt fra var optimalt.


Vi har derfor bygget et framework i python der kraftigt gør brug af numpy bestående af 4 filer: \texttt{proc.py, functions.py, main.py, constants.py}.

I \texttt{functions.py} ligger alle vores funktioner, disse inkluderer for eksempel: foldning med en gausskerne og difference of gaussians.
\texttt{constants.py} indeholder forskellige konstanter og foldningskerner. I \texttt{proc.py} kan funktionerne kaldes med forskellige parametre, på et eller flere billeder, i den rækkefølge man ønsker.
En procedure har følgende syntaks:
\begin{verbatim}
PROCEDURE_NAVN = (BILLEDNAVN, [
                 (funktion1,
                   {eventuelle parametre til den enkelte funktion}),
                 (funktion2,
                   {parametre}),])
\end{verbatim}
Funktionerne bliver udført som forventet, i den rækkefølge de forekommer i listen.
Da vi i flere af de metoder vi benytter os af behøver de helt rigtige parametre for at opnå et brugbart resultat, har ovenstående syntaks vist sig at være meget nyttig da parametrene blot skal ændres et sted.

Herefter tilføjes proceduren til en liste af procedurer. Denne liste pakkes ud og håndteres i \texttt{main.py}. Vores framework kaldes således: 
\begin{verbatim}
	python main.py <indeks i procedurelisten>
\end{verbatim}

Vi har været glade for at have haft dette framework som 
%læringsværktøj
læringssandkasse men det har vist sig at det til vores projekt er MATLAB underlegent af flere grunde:
\begin{itemize}
	\item Numpy/Scipy er ikke specielt tolerant overfor programmeringsfejl. De stacktraces der udskrives ved fejl bringer blot information om hvilke interne numpy-funktioner og peger ikke brugeren i retningen af en mulig løsning. Dette er tilfældet i selv nogle af de simpleste tilfælde, f.eks. ved matrixmultiplikation af to matricer af inkombatible dimensioner i %i numpy 1.5.1
	.
	\item Vi er flere gange i udviklingsforløbet stødt ind i at navngivningen af metoder i Scipy/Numpy er inkonsistent og ret forvirrende. 
	\item I numpy/scipy findes der ofte 2 udgaver af den samme metode, forskellen på disse er blot at den ene modtager 1-dimensionelle arrays (vektorer) som input, og den anden modtager et 2-dimmensionelt array (matricer) som input. Man har således både \texttt{scipy.signal.convolve()} og \texttt{scipy.signal.convolve2d()}. Matlabs ekvivalente metode er \texttt{conv()} der modtager både vektorer og matricer.
	\item Dokumentationen til Numpy/Scipy er til tider magelfuld og sjældne gange ikke eksisterende. 
\end{itemize}

Både MATLAB og Python har en interaktiv shell hvor man kan udforske forskellige af de indbyggede metoder på kørselstidspunktet. Begge miljøer understøtter kaldet \texttt{help()} der fremkalder dokumentationen af en funktion på kørselstidspunktet, problemet ved scipy/numpy er som sagt blot at den vedlagte dokumentation til tider er ret sparsom.

Vi har ligeledes fundet at MATLAB har væsentligt flere funktioner der har været meget bekvemme i vores tilfælde. Af disse kan nævnes \texttt{nlfilter} der blabla. Det er således rart at man ikke skal bekymre sig om at implementere nlfilteret men kan koncentrere sig om hvad det skal gøre. 
Derudover har vi også fundet det belejligt at der findes en funktion der kan rotere matricer 
%Spørg Claes

Vi har derfor valgt at implementere vores endelige værktøj i MATLAB da vi har fundet at vi simpelthen har kunnet opnå bedre resultater hurtigere med Matlab end med scipy/numpy. \bf{MERE} 
\subsection{Python}		% Marcus
\subsection{Matlab}		% Marcus
